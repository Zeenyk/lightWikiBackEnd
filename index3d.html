<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Interactive 3D Graph</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  
  body { 
    overflow: hidden; 
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
    background: #ffffff;
    touch-action: none;
  }
  
  #container { 
    width: 100vw; 
    height: 100vh; 
    position: relative;
  }
  
  canvas { 
    display: block; 
    cursor: pointer;
    background: #ffffff;
    touch-action: none;
  }
  
  canvas.dragging { 
    cursor: grabbing;
  }
  
  .node-hover {
    cursor: pointer !important;
  }
  
  #info { 
    position: absolute; 
    top: 20px; 
    left: 20px; 
    background: rgba(255, 255, 255, 0.95); 
    color: #333333;
    padding: 16px 20px; 
    border-radius: 12px; 
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15); 
    font-size: 13px;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(0, 0, 0, 0.1);
    line-height: 1.6;
  }
  
  #info strong { 
    color: #2c7fb8; 
    font-size: 15px;
    display: block;
    margin-bottom: 8px;
  }
  
  #nodeInfo {
    position: absolute;
    top: 20px;
    right: 20px;
    background: rgba(255, 255, 255, 0.95);
    color: #333333;
    padding: 16px 20px;
    border-radius: 12px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
    font-size: 13px;
    display: none;
    max-width: 300px;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(0, 0, 0, 0.1);
    line-height: 1.6;
  }
  
  #nodeInfo strong {
    color: #2c7fb8;
    font-size: 15px;
    display: block;
    margin-bottom: 8px;
  }
  
  #nodeInfo img {
    max-width: 100%;
    border-radius: 8px;
    margin-top: 10px;
    border: 2px solid rgba(44, 127, 184, 0.3);
  }
  
  #loading {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #2c7fb8;
    font-size: 18px;
    font-weight: 600;
  }
  
  .close-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    background: rgba(0, 0, 0, 0.1);
    border: none;
    color: #333333;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    cursor: pointer;
    font-size: 16px;
    line-height: 1;
    transition: all 0.2s;
  }
  
  .close-btn:hover {
    background: rgba(0, 0, 0, 0.2);
    transform: scale(1.1);
  }

  @media (max-width: 768px) {
    #info, #nodeInfo {
      font-size: 12px;
      padding: 12px 16px;
      max-width: 250px;
    }
    
    #info strong, #nodeInfo strong {
      font-size: 14px;
    }
  }
</style>
</head>
<body>

<div id="container">
  <div id="loading">Loading graph...</div>
  <canvas id="graph"></canvas>
  
  <div id="info">
    <strong>Controls</strong>
    â€¢ Mouse/Touch: Rotate<br>
    â€¢ Pinch/Wheel: Zoom<br>
    â€¢ Two fingers move: Pan<br>
    â€¢ Click/Tap node: Show info
  </div>
  
  <div id="nodeInfo">
    <button class="close-btn" onclick="document.getElementById('nodeInfo').style.display='none'">Ã—</button>
    <div id="nodeContent"></div>
  </div>
</div>

<script>
// Carica il grafo da file JSON
async function loadGraph() {
  try {
    const response = await fetch('graph3d.json');
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const data = await response.json();
    
    // Normalizza le coordinate per avere una scala migliore
    const coords = data.nodes.map(n => [n.x, n.y, n.z]);
    const maxDist = Math.max(...coords.flat().map(Math.abs));
    const scale = maxDist > 0 ? 1 / maxDist : 1;
    
    // Formatta i dati
    const graph = {
      nodes: data.nodes.map((node, i) => ({
        id: node.id,
        x: node.x * scale,
        y: node.y * scale,
        z: node.z * scale,
        blob: data.blobs && data.blobs[i] ? data.blobs[i].blob : null,
        color: null
      })),
      edges: data.edges.map(edge => ({
        source: edge.source,
        target: edge.target,
        weight: edge.weight || 0.5
      }))
    };
    
    // Trova i 4 nodi agli estremi
    const extremes = {
      minX: graph.nodes.reduce((min, n) => n.x < min.x ? n : min),
      maxX: graph.nodes.reduce((max, n) => n.x > max.x ? n : max),
      minY: graph.nodes.reduce((min, n) => n.y < min.y ? n : min),
      maxY: graph.nodes.reduce((max, n) => n.y > max.y ? n : max)
    };
    
    const extremeIds = new Set([
      extremes.minX.id,
      extremes.maxX.id,
      extremes.minY.id,
      extremes.maxY.id
    ]);
    
    // Colora i nodi
    const extremeColors = ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3'];
    let colorIndex = 0;
    
    graph.nodes.forEach(node => {
      if (extremeIds.has(node.id)) {
        node.color = extremeColors[colorIndex++ % 4];
        node.isExtreme = true;
      } else {
        const dist = Math.sqrt(node.x * node.x + node.y * node.y + node.z * node.z);
        const hue = 200 + dist * 100;
        node.color = `hsl(${hue % 360}, 70%, 45%)`;
        node.isExtreme = false;
      }
    });
    
    return graph;
  } catch (error) {
    console.error('Errore nel caricamento del grafo:', error);
    document.getElementById('loading').textContent = 
      'Error: Cannot load graph3d.json\nMake sure the file exists.';
    return null;
  }
}

class Graph3D {
  constructor(canvas, graph) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.graph = graph;
    
    this.rotationX = 0;
    this.rotationY = 0;
    this.zoom = 350;
    this.panX = 0;
    this.panY = 0;
    
    this.isDragging = false;
    this.isPanning = false;
    this.lastMouseX = 0;
    this.lastMouseY = 0;
    
    // ðŸ”½ VARIABILI AGGIUNTE PER PAN A DUE DITA ðŸ”½
    this.touchStart = null;
    this.initialZoom = 0;
    this.initialTouchDistance = 0;
    this.isPinching = false;
    this.twoFingerStart = null; // Per tracciare il pan a due dita
    this.panThreshold = 10; // Soglia per distinguere pan da zoom
    
    this.velocityX = 0;
    this.velocityY = 0;
    this.friction = 0.95;
    this.inertia = false;
    
    this.autoSpinDirection = 1;
    
    this.projectedNodes = [];
    
    this.setupCanvas();
    this.setupEvents();
    this.animate();
  }
  
  setupCanvas() {
    this.canvas.width = window.innerWidth;
    this.canvas.height = window.innerHeight;
    
    window.addEventListener('resize', () => {
      this.canvas.width = window.innerWidth;
      this.canvas.height = window.innerHeight;
    });
  }
  
  setupEvents() {
    // EVENTI MOUSE
    this.canvas.addEventListener('mousedown', (e) => {
      if (e.button === 1) {
        e.preventDefault();
        this.isPanning = true;
        this.canvas.style.cursor = 'move';
        this.inertia = false;
      } else if (e.button === 0) {
        this.isDragging = true;
        this.canvas.classList.add('dragging');
        this.inertia = false;
        this.velocityX = 0;
        this.velocityY = 0;
      }
      this.lastMouseX = e.clientX;
      this.lastMouseY = e.clientY;
      clickStartTime = Date.now();
      clickStartX = e.clientX;
      clickStartY = e.clientY;
    });
    
    this.canvas.addEventListener('mousemove', (e) => {
      if (this.isDragging) {
        const deltaX = e.clientX - this.lastMouseX;
        const deltaY = e.clientY - this.lastMouseY;
        
        this.velocityX = deltaX * 0.01;
        this.velocityY = deltaY * 0.01;
        
        this.rotationY += this.velocityX;
        this.rotationX += this.velocityY;
        
        this.lastMouseX = e.clientX;
        this.lastMouseY = e.clientY;
      } else if (this.isPanning) {
        const deltaX = e.clientX - this.lastMouseX;
        const deltaY = e.clientY - this.lastMouseY;
        
        this.panX += deltaX;
        this.panY += deltaY;
        
        this.lastMouseX = e.clientX;
        this.lastMouseY = e.clientY;
      } else {
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        const hoveredNode = this.findNodeAtPosition(mouseX, mouseY);
        if (hoveredNode) {
          this.canvas.style.cursor = 'pointer';
        } else {
          this.canvas.style.cursor = 'grab';
        }
      }
    });
    
    const stopDrag = () => {
      if (this.isDragging) {
        this.inertia = true;
      }
      this.isDragging = false;
      this.isPanning = false;
      this.canvas.classList.remove('dragging');
      this.canvas.style.cursor = 'grab';
    };
    
    this.canvas.addEventListener('mouseup', stopDrag);
    this.canvas.addEventListener('mouseleave', stopDrag);
    
    // ZOOM MOUSE
    this.canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      const zoomFactor = e.deltaY > 0 ? 0.92 : 1.08;
      this.zoom *= zoomFactor;
      this.zoom = Math.max(50, Math.min(3000, this.zoom));
    });
    
    // ðŸ”½ EVENTI TOUCH MIGLIORATI PER PAN A DUE DITA ðŸ”½
    this.canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      
      if (e.touches.length === 1) {
        // Singolo tocco - rotazione
        this.touchStart = {
          x: e.touches[0].clientX,
          y: e.touches[0].clientY
        };
        this.isDragging = true;
        this.inertia = false;
        this.velocityX = 0;
        this.velocityY = 0;
        this.isPinching = false;
      } else if (e.touches.length === 2) {
        // Doppio tocco - inizializza per zoom O pan
        this.isPinching = true;
        this.isDragging = false;
        
        // Salva posizione iniziale per distinguere tra zoom e pan
        this.twoFingerStart = {
          x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
          y: (e.touches[0].clientY + e.touches[1].clientY) / 2
        };
        
        this.initialZoom = this.zoom;
        this.initialTouchDistance = this.getTouchDistance(e.touches[0], e.touches[1]);
      }
    });
    
    this.canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      
      if (e.touches.length === 1 && this.touchStart && !this.isPinching) {
        // Rotazione con singolo dito
        const touch = e.touches[0];
        const deltaX = touch.clientX - this.touchStart.x;
        const deltaY = touch.clientY - this.touchStart.y;
        
        this.velocityX = deltaX * 0.005;
        this.velocityY = deltaY * 0.005;
        
        this.rotationY += this.velocityX;
        this.rotationX += this.velocityY;
        
        this.touchStart = {
          x: touch.clientX,
          y: touch.clientY
        };
      } else if (e.touches.length === 2 && this.isPinching) {
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        const currentDistance = this.getTouchDistance(touch1, touch2);
        const centerX = (touch1.clientX + touch2.clientX) / 2;
        const centerY = (touch1.clientY + touch2.clientY) / 2;
        
        // Calcola la variazione di distanza per lo zoom
        const distanceChange = Math.abs(currentDistance - this.initialTouchDistance);
        
        // ðŸ”½ DETERMINA SE Ãˆ ZOOM O PAN ðŸ”½
        if (distanceChange > this.panThreshold) {
          // ZOOM - la distanza tra le dita Ã¨ cambiata significativamente
          const zoomFactor = currentDistance / this.initialTouchDistance;
          this.zoom = this.initialZoom * zoomFactor;
          this.zoom = Math.max(50, Math.min(3000, this.zoom));
        } else {
          // PAN - le dita si muovono insieme senza cambiare distanza
          if (this.twoFingerStart) {
            const deltaX = centerX - this.twoFingerStart.x;
            const deltaY = centerY - this.twoFingerStart.y;
            
            // Applica il pan
            this.panX += deltaX;
            this.panY += deltaY;
            
            // Aggiorna la posizione di riferimento
            this.twoFingerStart = {
              x: centerX,
              y: centerY
            };
          }
        }
      }
    });
    
    this.canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      
      if (e.touches.length === 0) {
        // Tutte le dita sollevate
        if (this.isDragging) {
          this.inertia = true;
        }
        this.isDragging = false;
        this.isPinching = false;
        this.touchStart = null;
        this.twoFingerStart = null;
        this.initialTouchDistance = 0;
      } else if (e.touches.length === 1) {
        // Passa da zoom/pan a rotazione
        this.isPinching = false;
        this.touchStart = {
          x: e.touches[0].clientX,
          y: e.touches[0].clientY
        };
      } else if (e.touches.length === 2) {
        // Aggiorna la distanza iniziale per zoom continuo
        this.initialZoom = this.zoom;
        this.initialTouchDistance = this.getTouchDistance(e.touches[0], e.touches[1]);
        this.twoFingerStart = {
          x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
          y: (e.touches[0].clientY + e.touches[1].clientY) / 2
        };
      }
    });
    
    // Gestione tap per mobile (solo per nodi)
    this.canvas.addEventListener('touchend', (e) => {
      if (e.touches.length === 0 && !this.isPinching) {
        const rect = this.canvas.getBoundingClientRect();
        const touch = e.changedTouches[0];
        const touchX = touch.clientX - rect.left;
        const touchY = touch.clientY - rect.top;
        
        const tappedNode = this.findNodeAtPosition(touchX, touchY);
        if (tappedNode) {
          this.showNodeInfo(tappedNode);
        } else {
          document.getElementById('nodeInfo').style.display = 'none';
        }
      }
    });
    
    // Click su nodi (desktop)
    let clickStartTime = 0;
    let clickStartX = 0;
    let clickStartY = 0;
    
    this.canvas.addEventListener('mousedown', (e) => {
      clickStartTime = Date.now();
      clickStartX = e.clientX;
      clickStartY = e.clientY;
    });
    
    this.canvas.addEventListener('click', (e) => {
      const clickDuration = Date.now() - clickStartTime;
      const clickDistance = Math.sqrt(
        Math.pow(e.clientX - clickStartX, 2) + 
        Math.pow(e.clientY - clickStartY, 2)
      );
      
      if (clickDuration < 300 && clickDistance < 5) {
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        const clickedNode = this.findNodeAtPosition(mouseX, mouseY);
        if (clickedNode) {
          this.showNodeInfo(clickedNode);
        } else {
          document.getElementById('nodeInfo').style.display = 'none';
        }
      }
    });
  }
  
  getTouchDistance(touch1, touch2) {
    const dx = touch1.clientX - touch2.clientX;
    const dy = touch1.clientY - touch2.clientY;
    return Math.sqrt(dx * dx + dy * dy);
  }
  
  isUpsideDown() {
    const normalZ = Math.cos(this.rotationX) * Math.cos(this.rotationY);
    return normalZ < -0.3;
  }
  
  rotate3D(x, y, z) {
    const cosY = Math.cos(this.rotationY);
    const sinY = Math.sin(this.rotationY);
    const x1 = x * cosY - z * sinY;
    const z1 = x * sinY + z * cosY;
    
    const cosX = Math.cos(this.rotationX);
    const sinX = Math.sin(this.rotationX);
    const y2 = y * cosX - z1 * sinX;
    const z2 = y * sinX + z1 * cosX;
    
    return { x: x1, y: y2, z: z2 };
  }
  
  project3D(node) {
    const rotated = this.rotate3D(node.x, node.y, node.z);
    
    const perspective = 2;
    const scale = this.zoom / (perspective + rotated.z);
    const screenX = this.canvas.width / 2 + rotated.x * scale + this.panX;
    const screenY = this.canvas.height / 2 + rotated.y * scale + this.panY;
    
    return { 
      x: screenX, 
      y: screenY, 
      z: rotated.z, 
      scale: scale / this.zoom,
      visible: rotated.z > -perspective
    };
  }
  
  findNodeAtPosition(mouseX, mouseY) {
    const correctedX = mouseX - this.panX;
    const correctedY = mouseY - this.panY;
    
    for (let i = this.projectedNodes.length - 1; i >= 0; i--) {
      const node = this.projectedNodes[i];
      if (!node.projected.visible) continue;
      
      const radius = Math.max(6, 10 * node.projected.scale);
      const distance = Math.sqrt(
        Math.pow(correctedX - (node.projected.x - this.panX), 2) + 
        Math.pow(correctedY - (node.projected.y - this.panY), 2)
      );
      
      if (distance < radius) {
        return node;
      }
    }
    return null;
  }
  
  showNodeInfo(node) {
    const infoDiv = document.getElementById('nodeInfo');
    const contentDiv = document.getElementById('nodeContent');
    
    let html = `<strong>Node ${node.id}</strong>`;
    html += `Position: (${node.x.toFixed(3)}, ${node.y.toFixed(3)}, ${node.z.toFixed(3)})<br>`;
    
    const connections = this.graph.edges.filter(e => 
      e.source === node.id || e.target === node.id
    ).length;
    html += `Connections: ${connections}<br>`;
    
    if (node.blob) {
      html += `<img src="data:image/png;base64,${node.blob}" alt="Node ${node.id}" />`;
    }
    
    contentDiv.innerHTML = html;
    infoDiv.style.display = 'block';
  }
  
  draw() {
    const ctx = this.ctx;
    const w = this.canvas.width;
    const h = this.canvas.height;
    
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, w, h);
    
    this.projectedNodes = this.graph.nodes.map(node => ({
      ...node,
      projected: this.project3D(node)
    }));
    
    this.projectedNodes.sort((a, b) => a.projected.z - b.projected.z);
    
    this.graph.edges.forEach(edge => {
      const source = this.graph.nodes[edge.source];
      const target = this.graph.nodes[edge.target];
      
      const sourceProj = this.project3D(source);
      const targetProj = this.project3D(target);
      
      if (!sourceProj.visible || !targetProj.visible) return;
      
      const avgZ = (sourceProj.z + targetProj.z) / 2;
      const opacity = Math.max(0.2, Math.min(0.8, (avgZ + 2) / 4));
      
      ctx.strokeStyle = `rgba(44, 127, 184, ${opacity})`;
      ctx.lineWidth = Math.max(0.5, edge.weight * 2 * Math.max(sourceProj.scale, targetProj.scale));
      
      ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
      ctx.shadowBlur = 4;
      ctx.shadowOffsetX = 1;
      ctx.shadowOffsetY = 1;
      
      ctx.beginPath();
      ctx.moveTo(sourceProj.x, sourceProj.y);
      ctx.lineTo(targetProj.x, targetProj.y);
      ctx.stroke();
      
      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 0;
    });
    
    this.projectedNodes.forEach(node => {
      const p = node.projected;
      if (!p.visible) return;
      
      const radius = Math.max(6, 10 * p.scale);
      const opacity = Math.max(0.6, Math.min(1, (p.z + 2) / 4));
      
      ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
      ctx.shadowBlur = 12;
      ctx.shadowOffsetX = 3;
      ctx.shadowOffsetY = 3;
      
      ctx.fillStyle = node.color;
      ctx.globalAlpha = opacity;
      ctx.beginPath();
      ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
      ctx.shadowBlur = 6;
      ctx.shadowOffsetX = 2;
      ctx.shadowOffsetY = 2;
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      ctx.globalAlpha = 1;
      
      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 0;
      
      ctx.fillStyle = '#333333';
      ctx.font = `${Math.max(10, radius * 1.2)}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
      ctx.shadowBlur = 2;
      ctx.fillText(node.id, p.x, p.y - radius - 8);
      ctx.shadowColor = 'transparent';
    });
  }
  
  animate() {
    if (!this.isDragging) {
      const upsideDown = this.isUpsideDown();
      this.autoSpinDirection = upsideDown ? -1 : 1;
      
      this.rotationY += 0.0005 * this.autoSpinDirection;
    }
    
    if (this.inertia && (Math.abs(this.velocityX) > 0.001 || Math.abs(this.velocityY) > 0.001)) {
      this.rotationY += this.velocityX;
      this.rotationX += this.velocityY;
      
      this.velocityX *= this.friction;
      this.velocityY *= this.friction;
      
      if (Math.abs(this.velocityX) < 0.001 && Math.abs(this.velocityY) < 0.001) {
        this.velocityX = 0;
        this.velocityY = 0;
        this.inertia = false;
      }
    }
    
    this.draw();
    requestAnimationFrame(() => this.animate());
  }
}

// Inizializza caricando il grafo da JSON
const canvas = document.getElementById('graph');
loadGraph().then(graph => {
  if (graph) {
    document.getElementById('loading').style.display = 'none';
    new Graph3D(canvas, graph);
  }
});
</script>
</body>
</html>