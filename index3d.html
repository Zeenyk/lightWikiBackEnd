<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Interactive 3D Graph</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  
  body { 
    overflow: hidden; 
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
    background: #1a1a2e;
  }
  
  #container { 
    width: 100vw; 
    height: 100vh; 
    position: relative;
  }
  
  canvas { 
    display: block; 
    cursor: pointer;
    background: #0a0a1a;
  }
  
  canvas.dragging { 
    cursor: grabbing;
  }
  
  .node-hover {
    cursor: pointer !important;
  }
  
  #info { 
    position: absolute; 
    top: 20px; 
    left: 20px; 
    background: rgba(0, 0, 0, 0.85); 
    color: #e0e0e0;
    padding: 16px 20px; 
    border-radius: 12px; 
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4); 
    font-size: 13px;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    line-height: 1.6;
  }
  
  #info strong { 
    color: #5dade2; 
    font-size: 15px;
    display: block;
    margin-bottom: 8px;
  }
  
  #nodeInfo {
    position: absolute;
    top: 20px;
    right: 20px;
    background: rgba(0, 0, 0, 0.85);
    color: #e0e0e0;
    padding: 16px 20px;
    border-radius: 12px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    font-size: 13px;
    display: none;
    max-width: 300px;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    line-height: 1.6;
  }
  
  #nodeInfo strong {
    color: #5dade2;
    font-size: 15px;
    display: block;
    margin-bottom: 8px;
  }
  
  #nodeInfo img {
    max-width: 100%;
    border-radius: 8px;
    margin-top: 10px;
    border: 2px solid rgba(93, 173, 226, 0.3);
  }
  
  #loading {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #5dade2;
    font-size: 18px;
    font-weight: 600;
  }
  
  .close-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    background: rgba(255, 255, 255, 0.1);
    border: none;
    color: #e0e0e0;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    cursor: pointer;
    font-size: 16px;
    line-height: 1;
    transition: all 0.2s;
  }
  
  .close-btn:hover {
    background: rgba(255, 255, 255, 0.2);
    transform: scale(1.1);
  }
</style>
</head>
<body>

<div id="container">
  <div id="loading">Loading graph...</div>
  <canvas id="graph"></canvas>
  
  <div id="info">
    <strong>Controls</strong>
    • Mouse wheel: Zoom<br>
    • Left click + Drag: Rotate<br>
    • Middle click + Drag: Pan<br>
    • Click node: Show info<br>
    • Double click: Reset view
  </div>
  
  <div id="nodeInfo">
    <button class="close-btn" onclick="document.getElementById('nodeInfo').style.display='none'">×</button>
    <div id="nodeContent"></div>
  </div>
</div>

<script>
// Carica il grafo da file JSON
async function loadGraph() {
  try {
    const response = await fetch('graph3d.json');
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const data = await response.json();
    
    // Normalizza le coordinate per avere una scala migliore
    const coords = data.nodes.map(n => [n.x, n.y, n.z]);
    const maxDist = Math.max(...coords.flat().map(Math.abs));
    const scale = maxDist > 0 ? 1 / maxDist : 1;
    
    // Formatta i dati
    const graph = {
      nodes: data.nodes.map((node, i) => ({
        id: node.id,
        x: node.x * scale,
        y: node.y * scale,
        z: node.z * scale,
        blob: data.blobs && data.blobs[i] ? data.blobs[i].blob : null,
        color: null  // Verrà calcolato dopo
      })),
      edges: data.edges.map(edge => ({
        source: edge.source,
        target: edge.target,
        weight: edge.weight || 0.5
      }))
    };
    
    // Trova i 4 nodi agli estremi
    const extremes = {
      minX: graph.nodes.reduce((min, n) => n.x < min.x ? n : min),
      maxX: graph.nodes.reduce((max, n) => n.x > max.x ? n : max),
      minY: graph.nodes.reduce((min, n) => n.y < min.y ? n : min),
      maxY: graph.nodes.reduce((max, n) => n.y > max.y ? n : max)
    };
    
    const extremeIds = new Set([
      extremes.minX.id,
      extremes.maxX.id,
      extremes.minY.id,
      extremes.maxY.id
    ]);
    
    // Colora i nodi
    const extremeColors = ['#FF6B6B', '#4ECDC4', '#FFE66D', '#A8E6CF'];
    let colorIndex = 0;
    
    graph.nodes.forEach(node => {
      if (extremeIds.has(node.id)) {
        node.color = extremeColors[colorIndex++ % 4];
        node.isExtreme = true;
      } else {
        // Gradiente basato sulla distanza dal centro
        const dist = Math.sqrt(node.x * node.x + node.y * node.y + node.z * node.z);
        const hue = 200 + dist * 100;
        node.color = `hsl(${hue % 360}, 70%, 60%)`;
        node.isExtreme = false;
      }
    });
    
    return graph;
  } catch (error) {
    console.error('Errore nel caricamento del grafo:', error);
    document.getElementById('loading').textContent = 
      'Error: Cannot load graph3d.json\nMake sure the file exists.';
    return null;
  }
}

class Graph3D {
  constructor(canvas, graph) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.graph = graph;
    
    // Usiamo un quaternione semplice per la rotazione
    this.rotationX = 0;
    this.rotationY = 0;
    this.zoom = 350;
    this.panX = 0;
    this.panY = 0;
    
    // Parametri di interazione
    this.isDragging = false;
    this.isPanning = false;
    this.lastMouseX = 0;
    this.lastMouseY = 0;
    
    // Cache delle proiezioni
    this.projectedNodes = [];
    
    // Stelle per lo sfondo
    this.stars = [];
    this.generateStars();
    
    // Nebulosa per lo sfondo
    this.nebula = [];
    this.generateNebula();
    
    this.setupCanvas();
    this.setupEvents();
    this.animate();
  }
  
  generateStars() {
    // Genera 400 stelle casuali in una sfera
    for (let i = 0; i < 400; i++) {
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);
      const r = 3 + Math.random() * 2;  // Distanza dalle stelle
      
      this.stars.push({
        x: r * Math.sin(phi) * Math.cos(theta),
        y: r * Math.sin(phi) * Math.sin(theta),
        z: r * Math.cos(phi),
        size: Math.random() * 2 + 0.5,
        brightness: Math.random() * 0.7 + 0.3
      });
    }
  }
  
  generateNebula() {
    // Genera 20 zone di nebulosa per dare profondità
    for (let i = 0; i < 20; i++) {
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);
      const r = 2 + Math.random() * 3;
      
      this.nebula.push({
        x: r * Math.sin(phi) * Math.cos(theta),
        y: r * Math.sin(phi) * Math.sin(theta),
        z: r * Math.cos(phi),
        radius: 0.5 + Math.random() * 1,
        opacity: 0.1 + Math.random() * 0.15
      });
    }
  }
  
  setupCanvas() {
    this.canvas.width = window.innerWidth;
    this.canvas.height = window.innerHeight;
    
    window.addEventListener('resize', () => {
      this.canvas.width = window.innerWidth;
      this.canvas.height = window.innerHeight;
    });
  }
  
  setupEvents() {
    // Mouse drag per rotazione o pan
    this.canvas.addEventListener('mousedown', (e) => {
      if (e.button === 1) {  // Middle button (rotella)
        e.preventDefault();
        this.isPanning = true;
        this.canvas.style.cursor = 'move';
      } else if (e.button === 0) {  // Left button
        this.isDragging = true;
        this.canvas.classList.add('dragging');
      }
      this.lastMouseX = e.clientX;
      this.lastMouseY = e.clientY;
      clickStartTime = Date.now();
      clickStartX = e.clientX;
      clickStartY = e.clientY;
    });
    
    this.canvas.addEventListener('mousemove', (e) => {
      if (this.isDragging) {
        const deltaX = e.clientX - this.lastMouseX;
        const deltaY = e.clientY - this.lastMouseY;
        
        // Rotazione libera - Y per orizzontale, X per verticale
        this.rotationY += deltaX * 0.01;
        this.rotationX += deltaY * 0.01;
        
        // Mantieni gli angoli nel range 0-2π
        this.rotationX = this.rotationX % (Math.PI * 2);
        this.rotationY = this.rotationY % (Math.PI * 2);
        
        this.lastMouseX = e.clientX;
        this.lastMouseY = e.clientY;
      } else if (this.isPanning) {
        const deltaX = e.clientX - this.lastMouseX;
        const deltaY = e.clientY - this.lastMouseY;
        
        this.panX += deltaX;
        this.panY += deltaY;
        
        this.lastMouseX = e.clientX;
        this.lastMouseY = e.clientY;
      } else {
        // Cambia cursore quando si passa sopra un nodo
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        const hoveredNode = this.findNodeAtPosition(mouseX, mouseY);
        if (hoveredNode) {
          this.canvas.style.cursor = 'pointer';
        } else {
          this.canvas.style.cursor = 'grab';
        }
      }
    });
    
    const stopDrag = () => {
      this.isDragging = false;
      this.isPanning = false;
      this.canvas.classList.remove('dragging');
      this.canvas.style.cursor = 'grab';
    };
    
    this.canvas.addEventListener('mouseup', stopDrag);
    this.canvas.addEventListener('mouseleave', stopDrag);
    
    // Zoom con rotella
    this.canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      const zoomFactor = e.deltaY > 0 ? 0.92 : 1.08;
      this.zoom *= zoomFactor;
      this.zoom = Math.max(50, Math.min(3000, this.zoom));  // Range aumentato
    });
    
    // Reset con doppio click
    this.canvas.addEventListener('dblclick', () => {
      this.rotationX = 0;
      this.rotationY = 0;
      this.zoom = 350;
      this.panX = 0;
      this.panY = 0;
      document.getElementById('nodeInfo').style.display = 'none';
    });
    
    // Click su nodi
    let clickStartTime = 0;
    let clickStartX = 0;
    let clickStartY = 0;
    
    this.canvas.addEventListener('mousedown', (e) => {
      clickStartTime = Date.now();
      clickStartX = e.clientX;
      clickStartY = e.clientY;
    });
    
    this.canvas.addEventListener('click', (e) => {
      const clickDuration = Date.now() - clickStartTime;
      const clickDistance = Math.sqrt(
        Math.pow(e.clientX - clickStartX, 2) + 
        Math.pow(e.clientY - clickStartY, 2)
      );
      
      // Solo se è un click vero (non un drag)
      if (clickDuration < 300 && clickDistance < 5) {
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        const clickedNode = this.findNodeAtPosition(mouseX, mouseY);
        if (clickedNode) {
          this.showNodeInfo(clickedNode);
        } else {
          document.getElementById('nodeInfo').style.display = 'none';
        }
      }
    });
  }
  
  rotate3D(x, y, z) {
    // Rotazione semplice ma efficace - prima Y (orizzontale) poi X (verticale)
    
    // Rotazione Y (orizzontale)
    const cosY = Math.cos(this.rotationY);
    const sinY = Math.sin(this.rotationY);
    const x1 = x * cosY - z * sinY;
    const z1 = x * sinY + z * cosY;
    
    // Rotazione X (verticale)
    const cosX = Math.cos(this.rotationX);
    const sinX = Math.sin(this.rotationX);
    const y2 = y * cosX - z1 * sinX;
    const z2 = y * sinX + z1 * cosX;
    
    return { x: x1, y: y2, z: z2 };
  }
  
  project3D(node) {
    // Applica rotazioni
    const rotated = this.rotate3D(node.x, node.y, node.z);
    
    // Proiezione prospettica
    const perspective = 2;
    const scale = this.zoom / (perspective + rotated.z);
    const screenX = this.canvas.width / 2 + rotated.x * scale + this.panX;
    const screenY = this.canvas.height / 2 + rotated.y * scale + this.panY;
    
    return { 
      x: screenX, 
      y: screenY, 
      z: rotated.z, 
      scale: scale / this.zoom,
      visible: rotated.z > -perspective
    };
  }
  
  findNodeAtPosition(mouseX, mouseY) {
    // Correggi le coordinate del mouse per il pan
    const correctedX = mouseX - this.panX;
    const correctedY = mouseY - this.panY;
    
    for (let i = this.projectedNodes.length - 1; i >= 0; i--) {
      const node = this.projectedNodes[i];
      if (!node.projected.visible) continue;
      
      const radius = Math.max(6, 10 * node.projected.scale);
      const distance = Math.sqrt(
        Math.pow(correctedX - (node.projected.x - this.panX), 2) + 
        Math.pow(correctedY - (node.projected.y - this.panY), 2)
      );
      
      if (distance < radius) {
        return node;
      }
    }
    return null;
  }
  
  showNodeInfo(node) {
    const infoDiv = document.getElementById('nodeInfo');
    const contentDiv = document.getElementById('nodeContent');
    
    let html = `<strong>Node ${node.id}</strong>`;
    html += `Position: (${node.x.toFixed(3)}, ${node.y.toFixed(3)}, ${node.z.toFixed(3)})<br>`;
    
    // Conta le connessioni
    const connections = this.graph.edges.filter(e => 
      e.source === node.id || e.target === node.id
    ).length;
    html += `Connections: ${connections}<br>`;
    
    // Mostra il blob se disponibile
    if (node.blob) {
      html += `<img src="data:image/png;base64,${node.blob}" alt="Node ${node.id}" />`;
    }
    
    contentDiv.innerHTML = html;
    infoDiv.style.display = 'block';
  }
  
  drawBackground() {
    const ctx = this.ctx;
    const w = this.canvas.width;
    const h = this.canvas.height;
    
    // Sfondo con gradiente
    const gradient = ctx.createRadialGradient(w/2, h/2, 0, w/2, h/2, Math.max(w, h)/2);
    gradient.addColorStop(0, '#0a0a1a');
    gradient.addColorStop(1, '#1a1a2e');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, w, h);
    
    // Disegna nebulosa
    this.nebula.forEach(neb => {
      const rotated = this.rotate3D(neb.x, neb.y, neb.z);
      const perspective = 2;
      const scale = this.zoom / (perspective + rotated.z);
      const screenX = w/2 + rotated.x * scale + this.panX;
      const screenY = h/2 + rotated.y * scale + this.panY;
      
      if (rotated.z > -perspective) {
        const radius = neb.radius * scale;
        const opacity = Math.max(0, Math.min(neb.opacity, (rotated.z + 2) / 4));
        
        // Gradiente per la nebulosa
        const nebulaGradient = ctx.createRadialGradient(
          screenX, screenY, 0, 
          screenX, screenY, radius
        );
        nebulaGradient.addColorStop(0, `rgba(80, 100, 150, ${opacity})`);
        nebulaGradient.addColorStop(1, 'rgba(80, 100, 150, 0)');
        
        ctx.fillStyle = nebulaGradient;
        ctx.beginPath();
        ctx.arc(screenX, screenY, radius, 0, Math.PI * 2);
        ctx.fill();
      }
    });
    
    // Disegna stelle
    this.stars.forEach(star => {
      const rotated = this.rotate3D(star.x, star.y, star.z);
      const perspective = 2;
      const scale = this.zoom / (perspective + rotated.z);
      const screenX = w/2 + rotated.x * scale + this.panX;
      const screenY = h/2 + rotated.y * scale + this.panY;
      
      if (rotated.z > -perspective) {
        const size = star.size * scale;
        const opacity = Math.max(0, Math.min(star.brightness, (rotated.z + 2) / 4));
        
        // Stelle più luminose quando sono più vicine
        ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
        ctx.beginPath();
        ctx.arc(screenX, screenY, size, 0, Math.PI * 2);
        ctx.fill();
        
        // Effetto bagliore per stelle più grandi
        if (size > 1.5) {
          ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
          ctx.shadowBlur = size * 2;
          ctx.fill();
          ctx.shadowBlur = 0;
        }
      }
    });
  }
  
  draw() {
    const ctx = this.ctx;
    const w = this.canvas.width;
    const h = this.canvas.height;
    
    // Disegna lo sfondo con stelle e nebulosa
    this.drawBackground();
    
    // Proietta tutti i nodi
    this.projectedNodes = this.graph.nodes.map(node => ({
      ...node,
      projected: this.project3D(node)
    }));
    
    // Ordina per profondità (z crescente = più vicini)
    this.projectedNodes.sort((a, b) => a.projected.z - b.projected.z);
    
    // Disegna archi
    this.graph.edges.forEach(edge => {
      const source = this.graph.nodes[edge.source];
      const target = this.graph.nodes[edge.target];
      
      const sourceProj = this.project3D(source);
      const targetProj = this.project3D(target);
      
      if (!sourceProj.visible || !targetProj.visible) return;
      
      // Gradiente di profondità
      const avgZ = (sourceProj.z + targetProj.z) / 2;
      const opacity = Math.max(0.15, Math.min(0.6, (avgZ + 2) / 4));
      
      ctx.strokeStyle = `rgba(93, 173, 226, ${opacity})`;
      ctx.lineWidth = Math.max(0.5, edge.weight * 2 * Math.max(sourceProj.scale, targetProj.scale));
      ctx.beginPath();
      ctx.moveTo(sourceProj.x, sourceProj.y);
      ctx.lineTo(targetProj.x, targetProj.y);
      ctx.stroke();
    });
    
    // Disegna nodi
    this.projectedNodes.forEach(node => {
      const p = node.projected;
      if (!p.visible) return;
      
      const radius = Math.max(6, 10 * p.scale);
      const opacity = Math.max(0.5, Math.min(1, (p.z + 2) / 4));
      
      // Ombra
      ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
      ctx.shadowBlur = 8;
      ctx.shadowOffsetX = 2;
      ctx.shadowOffsetY = 2;
      
      // Cerchio interno
      ctx.fillStyle = node.color;
      ctx.globalAlpha = opacity;
      ctx.beginPath();
      ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
      ctx.fill();
      
      // Bordo
      ctx.shadowColor = 'transparent';
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      ctx.globalAlpha = 1;
      
      // Label - sempre visibili
      ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
      ctx.font = `${Math.max(10, radius * 1.2)}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      // Ombra testo
      ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
      ctx.shadowBlur = 4;
      ctx.fillText(node.id, p.x, p.y - radius - 8);
      ctx.shadowColor = 'transparent';
    });
  }
  
  animate() {
    // Rotazione automatica leggera quando non si sta trascinando
    if (!this.isDragging) {
      this.rotationY += 0.001;
    }
    
    this.draw();
    requestAnimationFrame(() => this.animate());
  }
}

// Inizializza caricando il grafo da JSON
const canvas = document.getElementById('graph');
loadGraph().then(graph => {
  if (graph) {
    document.getElementById('loading').style.display = 'none';
    new Graph3D(canvas, graph);
  }
});
</script>
</body>
</html>